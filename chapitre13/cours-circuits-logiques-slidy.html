<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Première NSI Lycée du Parc" />
  <title>Circuits combinatoires et logique booléenne</title>
  <style type="text/css">
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="https://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
   href="../Pandoc/style_nsi.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>
  <script src="https://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Circuits combinatoires et logique booléenne</h1>
  <p class="subtitle">Thèmes architectures matérielles et types de données de base</p>
  <p class="author">
Première NSI Lycée du Parc
  </p>
</div>
<div id="crédits" class="slide section level1 unnumbered">
<h1 class="unnumbered">Crédits</h1>
<p><em>Ce cours est largement inspiré du chapitre 22 du manuel NSI de la collection Tortue chez Ellipsen auteurs : Ballabonski, Conchon, Filliatre, N’Guyen.</em></p>
</div>
<div id="préambule" class="slide section level1 unnumbered">
<h1 class="unnumbered">Préambule</h1>
<p>Les circuits d’une ordinateur manipulent uniquement des 0 ou des 1 représentés en interne par des tensions hautes ou basses. Les premiers ordinateurs construits dans la période 1945-1950 sont basés sur une technologie de tube à vide ou tube électrique. En 1947, aux laboratoires Bell, <a href="https://fr.wikipedia.org/wiki/Transistor">Shockley, Bardeen et Brattain</a> inventent le <strong>transistor</strong> au <em>germanium</em> un petit composant électronique qui se comporte comme un interrupteur. Les transistors, plus petits et dissipant moins de chaleur, vont supplanter les tubes électriques : en 1954 le <em>germanium</em> est remplacé par le <em>silicium</em>, en 1955 apparaissent les premiers ordinateurs entièrement transistorisés, en 1960 le transistor à effet de champ permet l’intégration de dizaines composants dans un centimètre carré. Les transistors sont ensuite directement gravés dans une plaque de <em>silicium</em> constituant un <strong>cicrcuit intégré</strong>. En 1965 Gordon Moore futur directeur d’Intel énonce la <a href="https://fr.wikipedia.org/wiki/Loi_de_Moore">loi empirique</a> portant son nom qui fixe une feuille de route à l’industrie des mircroprocesseurs : le doublement de la densité d’intégration des transistors tous les deux ans. Cette loi s’est vérifiée jusqu’à présent avec une finesse de gravure d’environ 5 nanomètres en 2020. Le <a href="https://en.wikipedia.org/wiki/Moore%27s_law#/media/File:Moore&#39;s_Law_Transistor_Count_1971-2018.png">graphique</a> ci-dessous représente l’évolution du nombre de transistors par circuit intégré.</p>
<div class="center">
<p><img src="images/640px-Moores_Law_Transistor_Count_1971-2018.png" style="width:90.0%" alt="Loi de Moore Source : Wikipedia" /><br />
</p>
</div>
</div>
<div id="portes-logiques" class="slide section level1">
<h1>Portes logiques</h1>
<h2 id="le-transistor-porte-logique-de-base">Le transistor porte logique de base</h2>
<div class="definition">
<p>Un <strong>transistor</strong> possède trois broches : la grille, la sortie (ou drain) et la source soumis à des états de tension haute ou basse qu’on peut assimiler aux valeurs binaires 1 et 0 d’un <strong>bit</strong>. Si la tension appliquée sur la grille est haute (bit à 1) alors le transitor laisse passer le courant entre la source d’énergie et la sortie et cette dernière passe à l’état de tension basse (bit à 0), sinon la sortie reste en tension haute (bit 1).</p>
<p>Une <strong>fonction logique</strong> prend un ou plusieurs bits en entrée et retourne un ou plusieurs bits en sortie. Une <strong>porte logique</strong> est un circuit électronique représentant une <strong>fonction logique</strong>.</p>
<p>Une <strong>table logique</strong> représente les sorties produites par une fonction logique pour toutes les entrées possibles.</p>
<p>Un transistor représente une fonction logique dont le bit d’entrée est l’état de tension de la grille et le bit de sortie, l’état de tension de la sortie. La <strong>table logique</strong> (table 1) associée est celle du <strong>NON logique</strong> ou <strong>Inverseur</strong>.</p>
<p>Fichier de test <a href="http://www.cburch.com/logisim/">Logisim</a> : <a href="circuits_logisim/transistor.circ">transistor.circ</a>.</p>
</div>
<div class="center">
<p><img src="images/transistor.png" style="width:50.0%" alt="Transistor" /><br />
</p>
</div>
<table>
<caption><strong>Table logique d’une porte NON</strong></caption>
<thead>
<tr class="header">
<th align="center">A</th>
<th>B = NON(A)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">0</td>
<td>1</td>
</tr>
<tr class="even">
<td align="center">1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p><strong>Il existe deux conventions de représentation symbolique des portes logiques, une européenne et une américaine.</strong></p>
<div class="minipage" center="true">
<p><img src="images/porte_not_european.png" alt="porte NOT européeenne" /><br />
&amp; <img src="images/porte_not_american.png" alt="porte NOT américaine" /><br />
</p>
</div>
<p><a href="videos/transistor-definition1.mp4">Tutoriel video Logisim : le transistor</a></p>
<h2 id="dautres-portes-logiques">D’autres portes logiques</h2>
<h3 id="transistors-en-série-ou-en-parallèle">Transistors en série ou en parallèle</h3>
<div class="exercice">
<p>On donne ci-dessous les représentations de deux portes logiques :</p>
<ul>
<li>La <strong>porte NAND</strong> constituée de deux transistors en série</li>
<li>La <strong>porte NOR</strong> constituée de deux transistors en parallèle</li>
</ul>
<p>Chacune de ces portes logiques comportent deux bits d’entrée : A pour la grille du transistor 1 et B pour la grille du transistor 2 et un bit de sortie.</p>
<p>Compléter leurs tables logiques.</p>
<p>Vérifier avec <a href="http://www.cburch.com/logisim/">Logisim</a> et les fichiers <a href="circuits_logisim/porte_NAND.circ">porte_NAND.circ</a> et <a href="circuits_logisim/porte_NOR.circ">porte_NOR.circ</a>.</p>
<p><a href="videos/porteNAND.mp4">Tutoriel video Logisim : porte NAND</a></p>
<p><a href="videos/porteNOR.mp4">Tutoriel video Logisim : porte NOR</a></p>
<table>
<thead>
<tr class="header">
<th align="center">A</th>
<th>B</th>
<th>NAND(A, B)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">0</td>
<td>0</td>
<td></td>
</tr>
<tr class="even">
<td align="center">0</td>
<td>1</td>
<td></td>
</tr>
<tr class="odd">
<td align="center">1</td>
<td>0</td>
<td></td>
</tr>
<tr class="even">
<td align="center">1</td>
<td>1</td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th align="center">A</th>
<th>B</th>
<th>NOR(A, B)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">0</td>
<td>0</td>
<td></td>
</tr>
<tr class="even">
<td align="center">0</td>
<td>1</td>
<td></td>
</tr>
<tr class="odd">
<td align="center">1</td>
<td>0</td>
<td></td>
</tr>
<tr class="even">
<td align="center">1</td>
<td>1</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<div class="minipage" center="true">
<p><img src="images/porte_nand.png" style="width:80.0%" alt="Porte NAND" /><br />
&amp; <img src="images/porte_nor.png" style="width:80.0%" alt="Porte NOR" /><br />
</p>
</div>
<p><strong>Voici les représentations symboliques des portes logiques NAND et NOR :</strong></p>
<div class="minipage" center="true">
<p><img src="images/porte_nand_european.png" alt="Porte NAND européenne" /><br />
&amp; <img src="images/porte_nand_american.png" alt="Porte NAND américaine" /><br />
</p>
</div>
<div class="minipage" center="true">
<p><img src="images/porte_nor_european.png" alt="Porte NOR européenne" /><br />
&amp; <img src="images/porte_nor_american.png" alt="Porte NOR américaine" /><br />
</p>
</div>
<h3 id="portes-logiques-et-fonctions-logiques-élémentaires">Portes logiques et fonctions logiques élémentaires</h3>
<div class="exercice">
<p>Fichier de test <a href="http://www.cburch.com/logisim/">Logisim</a> : <a href="circuits_logisim/exercice2.circ">exercice2.circ</a>.</p>
<ol style="list-style-type: decimal">
<li>Compléter la table logique de la porte logique représentée par le circuit ci-dessous. Quelle porte logique peut-on ainsi représenter ?</li>
</ol>
<p><img src="images/porte_not_with_nor.png" alt="Porte NOT" /><br />
</p>
<table>
<thead>
<tr class="header">
<th align="center">A</th>
<th>B = f(A)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">0</td>
<td></td>
</tr>
<tr class="even">
<td align="center">1</td>
<td></td>
</tr>
</tbody>
</table>
<ol start="2" style="list-style-type: decimal">
<li>Compléter la table logique de la porte logique représentée par le circuit ci-dessous. Quelle fonction logique correspond à cette porte logique ?</li>
</ol>
<p><img src="images/porte_and_with_nor.png" style="width:60.0%" alt="Porte AND" /><br />
</p>
<table>
<thead>
<tr class="header">
<th align="center">A</th>
<th>B</th>
<th>C = g(A, B)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">0</td>
<td>0</td>
<td></td>
</tr>
<tr class="even">
<td align="center">0</td>
<td>1</td>
<td></td>
</tr>
<tr class="odd">
<td align="center">1</td>
<td>0</td>
<td></td>
</tr>
<tr class="even">
<td align="center">1</td>
<td>1</td>
<td></td>
</tr>
</tbody>
</table>
<p><a href="videos/exercice2.mp4">Tutoriel video Logisim : exercice 2</a></p>
</div>
<div class="exercice">
<p>Fichier de test <a href="http://www.cburch.com/logisim/">Logisim</a> : <a href="circuits_logisim/exercice3.circ">exercice3.circ</a>.</p>
<ol style="list-style-type: decimal">
<li>Compléter la table logique de la porte logique représentée par le circuit ci-dessous. Quelle porte logique peut-on ainsi représenter ?</li>
</ol>
<p><img src="images/porte_not_with_nand.png" alt="Porte NOT" /><br />
</p>
<table>
<thead>
<tr class="header">
<th align="center">A</th>
<th>B = f(A)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">0</td>
<td></td>
</tr>
<tr class="even">
<td align="center">1</td>
<td></td>
</tr>
</tbody>
</table>
<ol start="2" style="list-style-type: decimal">
<li>Compléter la table logique de la porte logique représentée par le circuit ci-dessous. Quelle fonction logique correspond à cette porte logique ?</li>
</ol>
<p><img src="images/porte_or_with_nand.png" style="width:60.0%" alt="Porte OR" /><br />
</p>
<table>
<thead>
<tr class="header">
<th align="center">A</th>
<th>B</th>
<th>C = g(A, B)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">0</td>
<td>0</td>
<td></td>
</tr>
<tr class="even">
<td align="center">0</td>
<td>1</td>
<td></td>
</tr>
<tr class="odd">
<td align="center">1</td>
<td>0</td>
<td></td>
</tr>
<tr class="even">
<td align="center">1</td>
<td>1</td>
<td></td>
</tr>
</tbody>
</table>
<p><a href="videos/exercice3.mp4">Tutoriel video Logisim : exercice 3</a></p>
</div>
<p><strong>Voici les représentations symboliques des portes logiques <code>AND</code> et <code>OR</code> :</strong></p>
<div class="minipage" center="true">
<p><img src="images/porte_and_european.png" alt="Porte AND européenne" /><br />
&amp; <img src="images/porte_and_american.png" alt="Porte AND américaine" /><br />
</p>
</div>
<div class="minipage" center="true">
<p><img src="images/porte_or_european.png" alt="Porte OR européenne" /><br />
&amp; <img src="images/porte_or_american.png" alt="Porte OR américaine" /><br />
</p>
</div>
<div class="exercice">
<ol style="list-style-type: decimal">
<li>Construire un circuit représentant une porte <code>OR</code> uniquement avec des portes <code>NOR</code>.</li>
<li>Construire un circuit représentant une porte <code>AND</code> uniquement avec des portes <code>NAND</code>.</li>
</ol>
<p>Ainsi chacune des portes, <code>NAND</code> ou <code>NOR</code> permet de construire les portes <code>NOT</code>, <code>OR</code>, <code>AND</code>. Toute porte logique pouvant s’exprimer à l’aide de ces trois portes, les portes <code>NAND</code> et <code>NOR</code> sont dites <em>universelles</em>.</p>
<p><a href="videos/exercice4.mp4">Tutoriel video Logisim : exercice 4</a></p>
</div>
</div>
<div id="fonctions-booléennes" class="slide section level1">
<h1>Fonctions booléennes</h1>
<h2 id="fonctions-booléennes-1">Fonctions booléennes</h2>
<div class="definition">
<ul>
<li>Un <strong>booléen</strong> est un type de données pouvant prendre deux valeurs <code>True</code> (Vrai) ou <code>False</code> (Faux) qu’on représente numériquement par un <strong>bit</strong> de valeur <span class="math inline">\(1\)</span> pour <code>True</code> ou <span class="math inline">\(0\)</span> pour <code>False</code>. Electroniquement, les valeurs 1 et 0 se traduisent respectivement par des tensions haute ou basse.</li>
<li>Une <strong>fonction booléenne</strong> <span class="math inline">\(f\)</span> associe un booléen à un ou plusieurs booléens.</li>
<li>Une <strong>fonction booléenne</strong> avec <span class="math inline">\(n\)</span> arguments est définie sur un ensemble <span class="math inline">\(\{0;1\}^n\)</span> à <span class="math inline">\(2^n\)</span> valeurs et prend ses valeurs dans <span class="math inline">\(\{0;1\}\)</span> qui a <span class="math inline">\(2\)</span> éléments. On peut recenser les <span class="math inline">\(2^n\)</span> évaluations d’une fonction booléenne à <span class="math inline">\(n\)</span> arguments dans une <strong>table de vérité</strong> qui la définit entièrement. Il existe <span class="math inline">\(2^{2^n}\)</span> fonctions booléennes à <span class="math inline">\(n\)</span> arguments.</li>
<li>Une <strong>porte logique</strong> est la représentation sous forme de circuit d’une fonction booléenne et sa <strong>table logique</strong> est la <strong>table de vérité</strong> de cette fonction.</li>
</ul>
</div>
<div class="exercice">
<ol style="list-style-type: decimal">
<li>Compléter la fonction <code>Python</code> ci-dessous pour qu’elle affiche la table de vérité d’une fonction booléenne à deux entrées. Expliquer le rôle de la fonction <code>int</code>.</li>
</ol>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">def</span> table_verite_2bits(fonction):</span>
<span id="cb1-2"><a href="#cb1-2"></a>    <span class="bu">print</span>(<span class="st">&#39;|</span><span class="sc">{:^10}</span><span class="st">|</span><span class="sc">{:^10}</span><span class="st">|</span><span class="sc">{:^15}</span><span class="st">|&#39;</span>.<span class="bu">format</span>(<span class="st">&#39;a&#39;</span>,<span class="st">&#39;b&#39;</span>,fonction.<span class="va">__name__</span><span class="op">+</span><span class="st">&#39;(a,b)&#39;</span>))</span>
<span id="cb1-3"><a href="#cb1-3"></a>    <span class="cf">for</span> a <span class="kw">in</span> .............:</span>
<span id="cb1-4"><a href="#cb1-4"></a>        <span class="cf">for</span> b <span class="kw">in</span> .............:</span>
<span id="cb1-5"><a href="#cb1-5"></a>            <span class="bu">print</span>(<span class="st">&#39;|</span><span class="sc">{:^10}</span><span class="st">|</span><span class="sc">{:^10}</span><span class="st">|</span><span class="sc">{:^15}</span><span class="st">|&#39;</span>.<span class="bu">format</span>(......, ......, </span>
<span id="cb1-6"><a href="#cb1-6"></a>            <span class="bu">int</span>(fonction(<span class="bu">bool</span>(a),<span class="bu">bool</span>(b)))))</span></code></pre></div>
<ol start="2" style="list-style-type: decimal">
<li>Vérifier que les tables de vérité affichées pour les fonctions <code>bool.__or__</code>, <code>bool.__and__</code> et <code>bool.__not__</code> sont correctes.</li>
</ol>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a>In [<span class="dv">4</span>]: table_verite_2bits(<span class="bu">bool</span>.<span class="fu">__or__</span>)                                                                                                                                           </span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="op">|</span>    a     <span class="op">|</span>    b     <span class="op">|</span>  <span class="fu">__or__</span>(a,b)  <span class="op">|</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="op">|</span>    <span class="dv">1</span>     <span class="op">|</span>    <span class="dv">1</span>     <span class="op">|</span>       <span class="dv">1</span>       <span class="op">|</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="op">|</span>    <span class="dv">1</span>     <span class="op">|</span>    <span class="dv">0</span>     <span class="op">|</span>       <span class="dv">1</span>       <span class="op">|</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="op">|</span>    <span class="dv">0</span>     <span class="op">|</span>    <span class="dv">1</span>     <span class="op">|</span>       <span class="dv">1</span>       <span class="op">|</span></span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="op">|</span>    <span class="dv">0</span>     <span class="op">|</span>    <span class="dv">0</span>     <span class="op">|</span>       <span class="dv">0</span>       <span class="op">|</span></span></code></pre></div>
<p><a href="videos/exercice5.mp4">Tutoriel video : exercice 5</a></p>
</div>
<div class="propriete">
<p>On peut exprimer toute fonction booléenne à l’aide de trois fonctions booléennes élémentaires :</p>
<ul>
<li>La <em>négation</em> de <span class="math inline">\(x\)</span> est une fonction à 1 bit d’entrée (unaire) notée <span class="math inline">\(\neg x\)</span> ou <span class="math inline">\(\overline{x}\)</span>.<br />
Si <code>x</code> est un booléen, sa <em>négation</em> est <code>not x</code> en <code>Python</code>.</li>
</ul>
<table>
<thead>
<tr class="header">
<th align="center"><span class="math inline">\(x\)</span></th>
<th><span class="math inline">\(\neg x\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">0</td>
<td></td>
</tr>
<tr class="even">
<td align="center">1</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>La <em>conjonction</em> de <span class="math inline">\(x\)</span> et <span class="math inline">\(y\)</span> est une fonction à 2 bits d’entrée (binaire) notée <span class="math inline">\(x \wedge y\)</span> ou <span class="math inline">\(x . y\)</span>.<br />
Si <code>x</code> et <code>y</code> sont des booléens, leur <em>conjonction</em> est <code>x and y</code> en <code>Python</code>.</li>
</ul>
<table>
<thead>
<tr class="header">
<th align="center"><span class="math inline">\(x\)</span></th>
<th><span class="math inline">\(y\)</span></th>
<th><span class="math inline">\(x \wedge y\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">0</td>
<td>0</td>
<td></td>
</tr>
<tr class="even">
<td align="center">0</td>
<td>1</td>
<td></td>
</tr>
<tr class="odd">
<td align="center">1</td>
<td>0</td>
<td></td>
</tr>
<tr class="even">
<td align="center">1</td>
<td>1</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>La <em>disconjonction</em> de <span class="math inline">\(x\)</span> et <span class="math inline">\(y\)</span> est une fonction à 2 bits d’entrée (binaire) notée <span class="math inline">\(x \vee y\)</span> ou <span class="math inline">\(x + y\)</span>.<br />
Si <code>x</code> et <code>y</code> sont des booléens, leur <em>disjonction</em> est <code>x or y</code> en <code>Python</code>.</li>
</ul>
<table>
<thead>
<tr class="header">
<th align="center"><span class="math inline">\(x\)</span></th>
<th><span class="math inline">\(y\)</span></th>
<th><span class="math inline">\(x \vee y\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">0</td>
<td>0</td>
<td></td>
</tr>
<tr class="even">
<td align="center">0</td>
<td>1</td>
<td></td>
</tr>
<tr class="odd">
<td align="center">1</td>
<td>0</td>
<td></td>
</tr>
<tr class="even">
<td align="center">1</td>
<td>1</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<div class="propriete">
<ol style="list-style-type: decimal">
<li>Les fonctions booléennes élémentaires respectent un certain nombre de règles qui permettent de simplifier les expressions booléennes complexes :</li>
</ol>
<ul>
<li><em>opérateur involutif</em> : <span class="math inline">\(\neg(\neg x) = x\)</span> et <span class="math inline">\(\overline{\overline{x}}=x\)</span></li>
<li><em>élément neutre</em> : <span class="math inline">\(1 \wedge x = x\)</span> et <span class="math inline">\(1 . x =x\)</span> ou <span class="math inline">\(0 \vee x = x\)</span> et <span class="math inline">\(0 + x =x\)</span></li>
<li><em>élément absorbant</em> : <span class="math inline">\(0 \wedge x = 0\)</span> et <span class="math inline">\(0 . x =0\)</span> ou <span class="math inline">\(1 \vee x = x\)</span> et <span class="math inline">\(1 + x =1\)</span></li>
<li><em>idempotence</em> : <span class="math inline">\(x \wedge x = x\)</span> et <span class="math inline">\(x . x =x\)</span> ou <span class="math inline">\(x \vee x = x\)</span> et <span class="math inline">\(x + x =x\)</span></li>
<li><em>complément</em> : <span class="math inline">\(x \wedge (\neg x) = 0\)</span> et <span class="math inline">\(x . (\overline{x}) =0\)</span> ou <span class="math inline">\(x \vee (\neg x) = 1\)</span> et <span class="math inline">\(x + \overline{x} =1\)</span></li>
<li><em>commutativité</em> : <span class="math inline">\(x \wedge y = y \wedge x\)</span> et <span class="math inline">\(x . y = y . x\)</span> ou <span class="math inline">\(x \vee y = y \vee x\)</span> et <span class="math inline">\(x + y = y + x\)</span></li>
<li><em>associativité</em> : <span class="math inline">\(x \wedge ( y \wedge z) = (x \wedge y) \wedge z\)</span> et <span class="math inline">\(x . (y . z) = (x . y) . z\)</span> ou <span class="math inline">\(x \vee ( y \vee z) = (x \vee y) \vee z\)</span> et <span class="math inline">\(x + (y + z) = (x + y) + z\)</span></li>
<li><em>distributivité</em> : <span class="math inline">\(x \wedge ( y \vee z) = (x \wedge y) \vee (x \wedge z)\)</span> et <span class="math inline">\(x . (y + z) = x . y + x . z\)</span> ou <span class="math inline">\(x \vee ( y \wedge z) = (x \vee y) \wedge (x \vee z)\)</span> et <span class="math inline">\(x + (y . z) = (x + y) . (x + z)\)</span></li>
<li><em>loi de Morgan</em> : <span class="math inline">\(\neg(x \wedge y) = \neg x \vee \neg y\)</span> et <span class="math inline">\(\overline{x . y} = \overline{x} + \overline{y}\)</span> ou <span class="math inline">\(\neg(x \vee y) = \neg x \wedge \neg y\)</span> et <span class="math inline">\(\overline{x + y} = \overline{x} . \overline{y}\)</span></li>
</ul>
<ol start="2" style="list-style-type: decimal">
<li>Les fonctions booléennes élémentaire respectent des règles de priorité : la <em>négation</em> est prioritaire sur la <em>conjonction</em> qui est prioritaire sur la <em>disjonction</em>.<br />
<strong>Il est recommandé de mettre des parenthèses plutôt que d’appliquer les règles de priorité dans l’écriture des expressions booléennes.</strong></li>
</ol>
</div>
<h2 id="qcm-types-e3c">QCM types E3C</h2>
<div class="exercice">
<ol style="list-style-type: decimal">
<li>Parmi les quatre expressions suivantes, laquelle s’évalue en True ?</li>
</ol>
<ul>
<li><p><strong>Réponse A :</strong> <code>False and (True and False)</code></p></li>
<li><p><strong>Réponse B :</strong> <code>False or (True and False)</code></p></li>
<li><p><strong>Réponse B :</strong> <code>True and (True and False)</code></p></li>
<li><p><strong>Réponse C :</strong> <code>True or (True and False)</code></p></li>
</ul>
<ol start="2" style="list-style-type: decimal">
<li>Sachant que l’expression <code>not(a or b)</code> a la valeur <code>True</code>, quelles peuvent être les valeurs des variables booléennes a et b ?</li>
</ol>
<ul>
<li><strong>Réponse A :</strong> <code>True</code> et <code>True</code></li>
<li><strong>Réponse B :</strong> <code>False</code> et <code>True</code></li>
<li><strong>Réponse C :</strong> <code>True</code> et <code>False</code></li>
<li><strong>Réponse D :</strong> <code>False</code> et <code>False</code></li>
</ul>
<ol start="3" style="list-style-type: decimal">
<li>Pour quelles valeurs booléennes des variables <code>a, b</code> et <code>c</code> l’expression <code>(a or b) and (not c)</code> a-t-elle pour valeur <code>True</code></li>
</ol>
<ul>
<li><strong>Réponse A :</strong> <code>a  = True b = False c = True</code></li>
<li><strong>Réponse B :</strong> <code>a  = True b = False c = False</code></li>
<li><strong>Réponse C :</strong> <code>a  = False b = False c = True</code></li>
<li><strong>Réponse D :</strong> <code>a  = False b = True  c = True</code></li>
</ul>
<ol start="4" style="list-style-type: decimal">
<li>Si A et B sont des variables booléennes, laquelle de ces expressions booléennes est équivalente<br />
à <code>(not A) or B</code> ?</li>
</ol>
<ul>
<li><strong>Réponse A :</strong> <code>(A and B) or (not A and B)</code></li>
<li><strong>Réponse B :</strong> <code>(A and B) or (not A and B) or (not A and not B)</code></li>
<li><strong>Réponse C :</strong> <code>(not A and B) or (not A and not B)</code></li>
<li><strong>Réponse D :</strong> <code>(A and B) or (not A and not B)</code></li>
</ul>
<ol start="5" style="list-style-type: decimal">
<li>Choisir une expression booléenne pour la variable S qui satisfait la table de vérité suivante.</li>
</ol>
<table>
<thead>
<tr class="header">
<th align="left">A</th>
<th align="left">B</th>
<th align="left">S</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr class="odd">
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>Réponse A :</strong> A ou (non B)</li>
<li><strong>Réponse B :</strong> (non A) ou B</li>
<li><strong>Réponse C :</strong> (non A) ou (non B)</li>
<li><strong>Réponse D :</strong> non (A ou B)</li>
</ul>
<ol start="6" style="list-style-type: decimal">
<li>On considère une formule booléenne form des variables booléennes <code>a</code> et <code>b</code> dont voici la table de vérité.</li>
</ol>
<table>
<thead>
<tr class="header">
<th align="left">a</th>
<th align="left">b</th>
<th>form</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">True</td>
<td align="left">True</td>
<td>False</td>
</tr>
<tr class="even">
<td align="left">False</td>
<td align="left">True</td>
<td>False</td>
</tr>
<tr class="odd">
<td align="left">True</td>
<td align="left">False</td>
<td>True</td>
</tr>
<tr class="even">
<td align="left">False</td>
<td align="left">False</td>
<td>False</td>
</tr>
</tbody>
</table>
<p>Quelle est cette formule booléenne ?</p>
<ul>
<li><strong>Réponse A :</strong> <code>a and b</code></li>
<li><strong>Réponse B :</strong> <code>a or b</code></li>
<li><strong>Réponse C :</strong> <code>a and not(b)</code></li>
<li><strong>Réponse D :</strong> <code>not(a) or b</code></li>
</ul>
<p><a href="videos/exercice6.mp4">Tutoriel video : exercice 6</a></p>
</div>
<h2 id="pour-aller-plus-loin-hors-programme-de-première-nsi">Pour aller plus loin (hors programme de première NSI)</h2>
<h3 id="dresser-la-table-de-vérité-dune-fonction-booléenne">Dresser la table de vérité d’une fonction booléenne</h3>
<div class="exercice">
<p>Démontrer dans chaque cas l’égalité des expressions booléennes en utilisant les deux méthodes suivantes :</p>
<ul>
<li><p><strong>Méthode 1</strong> : en comparant les tables de vérité des deux expressions booléennes ;</p></li>
<li><p><strong>Méthode 2</strong> : en utilisant les règles de simplification de la propriété 2.</p></li>
</ul>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(x + x . y = x\)</span></li>
<li><span class="math inline">\(x + \overline{x} . y= x + y\)</span></li>
<li><span class="math inline">\(x . z + \overline{x} . y + y . z = x . z + \overline{x} . y\)</span></li>
<li><span class="math inline">\(\overline{y . (x + \overline{y})} = \overline{x} + \overline{y}\)</span></li>
<li><span class="math inline">\(x . ( \overline{x} + \overline{y}) . (x + y) = x . \overline{y}\)</span></li>
</ol>
</div>
<h3 id="exprimer-une-fonction-booléenne-à-partir-de-sa-table-de-vérité">Exprimer une fonction booléenne à partir de sa table de vérité</h3>
<div class="exercice">
<p>On considère la fonction booléenne dont la table de vérité est :</p>
<table>
<thead>
<tr class="header">
<th align="center"><span class="math inline">\(x\)</span></th>
<th><span class="math inline">\(y\)</span></th>
<th><span class="math inline">\(f(x, y)\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td align="center">0</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td align="center">1</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="even">
<td align="center">1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<ol style="list-style-type: decimal">
<li>Exprimer chacune des lignes où la fonction prend la valeur <span class="math inline">\(1\)</span> comme la <em>conjonction</em> des entrées en remplaçant chaque <span class="math inline">\(1\)</span> par la variable qu’il représente et chaque <span class="math inline">\(0\)</span> par la négation de la variable. Par exemple le <span class="math inline">\(1\)</span> de la deuxième ligne s’écrira <span class="math inline">\(\overline{x} . y\)</span>.</li>
<li>On peut alors écrire <span class="math inline">\(f(x,y)\)</span> comme la <em>disjonction</em> des <em>formes conjonctives</em> obtenues à la question précédente. En déduire une expression booléenne de <span class="math inline">\(f(x, y)\)</span>.</li>
<li>Ouvrir le logiciel <a href="http://www.cburch.com/logisim/">Logisim</a> et construire une porte logique représentant cette fonction booléenne.</li>
<li>Cette fonction s’appelle <code>OU EXCLUSIF</code> ou <code>XOR</code>. Ce nom vous paraît-il bien choisi ?</li>
</ol>
</div>
<p><strong>Voici les représentations symboliques de la porte logique <code>XOR</code> :</strong></p>
<div class="minipage" center="true">
<p><img src="images/porte_xor_european.png" alt="Porte XOR europeenne" /><br />
&amp; <img src="images/porte_xor_american.png" alt="Porte XOR americaine" /><br />
</p>
</div>
</div>
<div id="circuits-combinatoires" class="slide section level1">
<h1>Circuits combinatoires</h1>
<h2 id="définition">Définition</h2>
<div class="definition">
<p>Un <strong>circuit logique combinatoire</strong> permet de réaliser une ou plusieurs fonctions booléennes : ses sorties ne dépendent que de l’état actuel de ses entrées. Les portes logiques <code>NOT</code>, <code>NOR</code>, <code>NAND</code>, <code>AND</code>, <code>OR</code> et <code>XOR</code> sont des circuits combinatoires.</p>
<p>Il existe d’autres circuits, dits séquentiels, dont les sorties se calculent non seulement à partir de leurs valeurs d’entrée actuelles mais aussi à partir de leurs états précédents : le facteur temps intervient. Ils utilisent des circuits de mémoire pour mémoriser leurs états antérieurs.</p>
</div>
<div class="exercice">
<p>On considère la fonction booléeenne <span class="math inline">\(f\)</span> dont la table de vérité est donnée ci-dessous :</p>
<table>
<thead>
<tr class="header">
<th align="center"><span class="math inline">\(x\)</span></th>
<th><span class="math inline">\(y\)</span></th>
<th><span class="math inline">\(f(x, y)\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">0</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="even">
<td align="center">0</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="odd">
<td align="center">1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td align="center">1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<ol style="list-style-type: decimal">
<li><p>En utilisant la méthode exposée dans l’exercice 8, déterminer une expression booléenne de la fonction <span class="math inline">\(f\)</span>.</p></li>
<li><p>Ouvrir le logiciel <a href="http://www.cburch.com/logisim/">Logisim</a> et construire un circuit combinatoire représentant cette fonction booléenne :</p>
<ul>
<li>En utilisant les portes logiques <code>NOT</code>, <code>NOR</code>, <code>NAND</code>, <code>AND</code>, <code>OR</code> ou <code>XOR</code>.</li>
<li>En n’utilisant que des portes logiques <code>NOT</code>, <code>AND</code> ou <code>OR</code>.</li>
<li>En n’utilisant que des portes logiques <code>NOR</code>.</li>
</ul></li>
</ol>
<p><a href="videos/exercice9.mp4">Tutoriel video : exercice 9</a></p>
</div>
<h2 id="décodeur-avec-2-bits-dentrées">Décodeur avec 2 bits d’entrées</h2>
<div class="exercice">
<p>On considère un circuit combinatoire qui possède deux entrées <span class="math inline">\(e_{0}\)</span> et <span class="math inline">\(e_{1}\)</span> et quatre sorties <span class="math inline">\(s_{0}\)</span>, <span class="math inline">\(s_{1}\)</span>, <span class="math inline">\(s_{2}\)</span> et <span class="math inline">\(s_{3}\)</span>.</p>
<p>La sortie indexée par le nombre dont le bit de poids faible est <span class="math inline">\(e_{0}\)</span> et le bit de poids fort <span class="math inline">\(e_{1}\)</span>, est positionnée à <span class="math inline">\(1\)</span> et les autres sorties à <span class="math inline">\(0\)</span>. Ce circuit est ainsi appelé <strong>décodeur <span class="math inline">\(2\)</span> bits</strong>.</p>
<ol style="list-style-type: decimal">
<li>Compléter la table de vérité de ce circuit combinatoire.</li>
</ol>
<table>
<thead>
<tr class="header">
<th align="center"><span class="math inline">\(e_{0}\)</span></th>
<th><span class="math inline">\(e_{1}\)</span></th>
<th><span class="math inline">\(s_{0}\)</span></th>
<th><span class="math inline">\(s_{1}\)</span></th>
<th><span class="math inline">\(s_{2}\)</span></th>
<th><span class="math inline">\(s_{3}\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">0</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td align="center">0</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td align="center">1</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td align="center">1</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ol start="2" style="list-style-type: decimal">
<li><p>En utilisant la méthode exposée dans l’exercice 7, déterminer une expression booléenne de chacune des sorties <span class="math inline">\(s_{0}\)</span>, <span class="math inline">\(s_{1}\)</span>, <span class="math inline">\(s_{2}\)</span> et <span class="math inline">\(s_{3}\)</span>, en fonction des entrées <span class="math inline">\(e_{0}\)</span> et <span class="math inline">\(e_{1}\)</span>.</p></li>
<li><p>Ouvrir le logiciel <a href="http://www.cburch.com/logisim/">Logisim</a> et construire un circuit combinatoire représentant un <strong>décodeur <span class="math inline">\(2\)</span> bits</strong>.</p></li>
</ol>
</div>
<h2 id="demi-additionneur-et-additionneur-1-bit">Demi-additionneur et additionneur 1 bit</h2>
<div class="exercice">
<ol style="list-style-type: decimal">
<li><p>Effectuer les additions binaires : <span class="math inline">\(0+0\)</span>, <span class="math inline">\(0+1\)</span>, <span class="math inline">\(1+0\)</span> et <span class="math inline">\(1+1\)</span>.</p></li>
<li><p>Un <strong>demi-additionneur binaire 1 bit</strong> est un circuit combinatoire qui possède :</p>
<ul>
<li>deux entrées : deux bits d’opérande <span class="math inline">\(e_{0}\)</span> et <span class="math inline">\(e_{1}\)</span> ;</li>
<li>deux sorties : un bit de résultat <span class="math inline">\(s\)</span> et un bit de retenue sortante <span class="math inline">\(r\)</span>.</li>
</ul></li>
</ol>
<p>La sortie <span class="math inline">\(s\)</span> prend pour valeur le bit des unités et la sortie <span class="math inline">\(r\)</span> le bit de retenue sortante, lorsqu’on additionne les deux bits d’entrée <span class="math inline">\(e_{0}\)</span> et <span class="math inline">\(e_{1}\)</span>.</p>
<ol style="list-style-type: decimal">
<li>Compléter la table de vérité de ce circuit combinatoire :</li>
</ol>
<table>
<thead>
<tr class="header">
<th align="center"><span class="math inline">\(e_{0}\)</span></th>
<th><span class="math inline">\(e_{1}\)</span></th>
<th><span class="math inline">\(s\)</span></th>
<th><span class="math inline">\(r\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">0</td>
<td>0</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td align="center">0</td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td align="center">1</td>
<td>0</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td align="center">1</td>
<td>1</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ol start="4" style="list-style-type: decimal">
<li>Justifier qu’un <strong>demi-additionneur binaire 1 bit</strong> peut être représenté par le circuit ci-dessous.</li>
</ol>
<p><img src="images/demi_additionneur.png" style="width:50.0%" alt="Demi-additionneur binaire" /><br />
</p>
<ol start="5" style="list-style-type: decimal">
<li>Ouvrir le logiciel <a href="http://www.cburch.com/logisim/">Logisim</a> et construire un circuit combinatoire représentant un <strong>demi-additionneur binaire 1 bit</strong>.</li>
</ol>
<p><a href="videos/exercice11.mp4">Tutoriel video : exercice 11</a></p>
</div>
<div class="exercice">
<p>Un <strong>additionneur binaire 1 bit</strong> est un circuit combinatoire qui possède :</p>
<ul>
<li>trois entrées : deux bits d’opérande <span class="math inline">\(e_{0}\)</span> et <span class="math inline">\(e_{1}\)</span> et un bit de retenue entrante <span class="math inline">\(r_{0}\)</span></li>
<li>deux bits de sortie : un bit de résultat <span class="math inline">\(s_{2}\)</span> et un bit de retenue sortante <span class="math inline">\(r_{3}\)</span>.</li>
</ul>
<ol style="list-style-type: decimal">
<li>Compléter les colonnes de la table de vérité d’un <strong>additionneur binaire 1 bit</strong> pour le bit de résultat <span class="math inline">\(s_{2}\)</span> et le bit retenue sortante <span class="math inline">\(r_{3}\)</span>.</li>
</ol>
<table>
<colgroup>
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="17%" />
<col width="15%" />
<col width="17%" />
<col width="15%" />
<col width="15%" />
</colgroup>
<thead>
<tr class="header">
<th align="center"><span class="math inline">\(e_{0}\)</span></th>
<th><span class="math inline">\(e_{1}\)</span></th>
<th><span class="math inline">\(r_{0}\)</span></th>
<th><span class="math inline">\(s_{1}=\ldots \ldots\)</span></th>
<th><span class="math inline">\(r_{1}=\ldots \ldots\)</span></th>
<th><span class="math inline">\(s_{2}=\ldots \ldots\)</span></th>
<th><span class="math inline">\(r_{2}=\ldots \ldots\)</span></th>
<th><span class="math inline">\(r_{3}=\ldots \ldots\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">0</td>
<td>0</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td align="center">0</td>
<td>1</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td align="center">1</td>
<td>0</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td align="center">1</td>
<td>1</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td align="center">0</td>
<td>0</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td align="center">0</td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td align="center">1</td>
<td>0</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td align="center">1</td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ol start="2" style="list-style-type: decimal">
<li><p>Un <strong>additionneur binaire 1 bit</strong> peut être réalisé à l’aide de deux <strong>demi-additionneurs binaires 1 bit</strong> :</p>
<ul>
<li>Le premier <strong>demi-additionneur binaire 1 bit</strong> prend en entrée les bits d’opérande <span class="math inline">\(e_{0}\)</span> et <span class="math inline">\(e_{1}\)</span> et retourne en sortie un bit de résultat intermédiaire <span class="math inline">\(s_{1}\)</span> et un bit de retenue sortante intermédiaire <span class="math inline">\(r_{1}\)</span>. Donner une expression booléenne de <span class="math inline">\(s_{1}\)</span> et <span class="math inline">\(r_{1}\)</span> en fonction de <span class="math inline">\(e_{0}\)</span> et <span class="math inline">\(e_{1}\)</span>.</li>
<li>Le second <strong>demi-additionneur binaire 1 bit</strong> prend en entrée le bit de résultat <span class="math inline">\(s_{1}\)</span> et le bit de retenue entrante <span class="math inline">\(r_{0}\)</span> et retourne en sortie le bit de résultat final <span class="math inline">\(s_{2}\)</span> et un bit de retenue sortante intermédiaire <span class="math inline">\(r_{2}\)</span>. Donner une expression booléenne de <span class="math inline">\(s_{2}\)</span> et <span class="math inline">\(r_{2}\)</span> en fonction de <span class="math inline">\(s_{1}\)</span> et <span class="math inline">\(r_{0}\)</span>.</li>
<li>Enfin, la retenue sortante <span class="math inline">\(r_{3}\)</span> s’obtient à partir de la retenue sortante <span class="math inline">\(r_{1}\)</span> du premier demi-additionneur et de la retenue sortante <span class="math inline">\(r_{2}\)</span> du second. Donner une expression booléenne de <span class="math inline">\(r_{3}\)</span> en fonction de <span class="math inline">\(r_{1}\)</span> et <span class="math inline">\(r_{2}\)</span>.</li>
</ul>
<p>Compléter les colonnes <span class="math inline">\(s_{1}\)</span>, <span class="math inline">\(r_{1}\)</span> et <span class="math inline">\(r_{2}\)</span> puis <span class="math inline">\(s_{2}\)</span> et <span class="math inline">\(r_{3}\)</span> de la table de vérité de l’<strong>additionneur binaire à 1 bit</strong>.</p></li>
<li><p>Avec le logiciel <a href="http://www.cburch.com/logisim/">Logisim</a> ouvrir le fichier contenant le demi-additionneur de l’exercice précédent.</p>
<ul>
<li>Ajouter un nouveau circuit avec <code>Add a circuit</code> , le nommer <code>additionneur1bit</code> puis copier/coller dedans le circuit du <strong>demi-additionneur binaire 1 bit</strong>. Compléter le circuit pour obtenir un <strong>additionneur binaire 1 bit</strong>.</li>
<li>Ajouter un nouveau circuit avec <code>Add a circuit</code> , le nommer <code>additionneur2bits</code> puis copier/coller dedans le circuit de l’ <strong>additionneur binaire 1 bit</strong>. Compléter le circuit pour obtenir un <strong>additionneur binaire 2 bits</strong>.</li>
</ul></li>
</ol>
<p><a href="videos/exercice12.mp4">Tutoriel video : exercice 12</a></p>
</div>
</div>
<div id="opérations-bit-à-bit-en-python-hors-programme-de-première-nsi" class="slide section level1">
<h1>Opérations bit à bit en <code>Python</code> (hors programme de première NSI)</h1>
<div class="propriete">
<p>Les fonctions booléennes élémentaires (<code>OR</code>, <code>AND</code>, <code>NOT</code>, <code>XOR</code>) existent en <code>Python</code> sous la forme d’opérateurs booléens mais sont également implémentés sous la forme d’opérateurs bit à bit sur les nombres. Un <em>opérateur bit à bit</em> (<em>bitwise</em> en anglais) s’applique sur les bits de même poids des représentations binaires de ses opérandes.</p>
<table>
<colgroup>
<col width="25%" />
<col width="23%" />
<col width="50%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Opérateur booléen</th>
<th>Opérateur bit à bit</th>
<th align="left">Exemple</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>and</code> , ET</td>
<td><code>&amp;</code></td>
<td align="left"><code>&gt;&gt;&gt; bin(0b101001 &amp; 0b101010)</code></td>
</tr>
<tr class="even">
<td align="left"></td>
<td></td>
<td align="left"><code>'0b101000'</code></td>
</tr>
<tr class="odd">
<td align="left"><code>or</code> , OU</td>
<td><code>|</code></td>
<td align="left"><code>&gt;&gt;&gt; bin(0b101001 | 0b101010)</code></td>
</tr>
<tr class="even">
<td align="left"></td>
<td></td>
<td align="left"><code>'0b101011'</code></td>
</tr>
<tr class="odd">
<td align="left"><code>xor</code> , OU EXCLUSIF</td>
<td><code>^</code></td>
<td align="left"><code>&gt;&gt;&gt; bin(0b101001 ^ 0b101010)</code></td>
</tr>
<tr class="even">
<td align="left"></td>
<td></td>
<td align="left"><code>'0b000011'</code></td>
</tr>
<tr class="odd">
<td align="left"><code>not</code> , NEGATION</td>
<td><code>~</code></td>
<td align="left"><code>&gt;&gt;&gt; ~5 #~x retourne -x - 1</code></td>
</tr>
<tr class="even">
<td align="left"></td>
<td></td>
<td align="left"><code>-6</code></td>
</tr>
</tbody>
</table>
</div>
<p>Exemples d’utilisation d’opérateurs bit à bit :</p>
<ul>
<li>On peut utiliser le <code>ET</code> bit à bit pour sélectionner uniquement certains bits, par exemple les bits de rang pairs :</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a><span class="op">&gt;&gt;&gt;</span> bits_pairs <span class="op">=</span> <span class="bu">sum</span>(<span class="dv">2</span> <span class="op">**</span> k <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">8</span>, <span class="dv">2</span>))</span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">bin</span>(bits_pairs)</span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="co">&#39;0b1010101&#39;</span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">bin</span>(<span class="dv">183</span>)</span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="co">&#39;0b10110111&#39;</span></span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">bin</span>(<span class="dv">183</span> <span class="op">&amp;</span> bits_pairs)</span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="co">&#39;0b10100010&#39;</span></span></code></pre></div>
<ul>
<li>Le <code>OU EXCLUSIF</code> peut servir à masquer / démasquer une partie de la représentation binaire d’un nombre (on peut l’employer avec tout objet codé numériquement comme une image ou un caractère).</li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a><span class="op">&gt;&gt;&gt;</span> diego <span class="op">=</span> <span class="dv">69</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="op">&gt;&gt;&gt;</span> masque <span class="op">=</span> <span class="dv">42</span></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="op">&gt;&gt;&gt;</span> zorro <span class="op">=</span> diego <span class="op">^</span> masque</span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="op">&gt;&gt;&gt;</span> zorro</span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="dv">111</span></span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="op">&gt;&gt;&gt;</span> zorro <span class="op">^</span> masque</span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="dv">69</span></span></code></pre></div>
<div class="exercice">
<p>Dans un réseau <code>IP</code> l’adresse <code>IP</code> d’une machine est constituée d’un préfixe correspondant à l’adresse du réseau (commune à toutes les machines du réseau) et à un suffixe machine, identifiant la machine sur le réseau.</p>
<p>Le préfixe réseau s’obtient à partir de l’adresse <code>IP</code> de la machine en faisant un <code>ET</code> bit à bit avec le masque de sous-réseau.</p>
<p>Par exemple si l’adresse est <code>192.168.11.12</code> de représentation binaire <code>11000000.10101000.00001011.00001011</code> et le masque de sous-réseau est <code>255.255.252.0</code> de représentation binaire</p>
<p><code>11111111.11111111.11111100.00000000</code> alors le préfixe réseau est <code>11000000.10101000.00001000.00000000</code> soit <code>192.168.8.0</code>.</p>
<p>On donne ci-dessous deux fonctions outils :</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">def</span> ip2liste(ip):</span>
<span id="cb5-2"><a href="#cb5-2"></a>    <span class="co">&quot;Transforme une  adresse IP V4 (type str) en liste d&#39;entiers&quot;</span></span>
<span id="cb5-3"><a href="#cb5-3"></a>    <span class="cf">return</span> [<span class="bu">int</span>(champ) <span class="cf">for</span> champ <span class="kw">in</span> ip.split(<span class="st">&#39;.&#39;</span>)]</span>
<span id="cb5-4"><a href="#cb5-4"></a></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="kw">def</span> liste2ip(ipliste):</span>
<span id="cb5-6"><a href="#cb5-6"></a>    <span class="co">&quot;Transforme une  liste d&#39;entiers en adresse IP V4 (type str)&quot;</span></span>
<span id="cb5-7"><a href="#cb5-7"></a>    <span class="cf">return</span> <span class="st">&#39;.&#39;</span>.join(<span class="bu">str</span>(n) <span class="cf">for</span> n <span class="kw">in</span> ipliste)</span></code></pre></div>
<ol style="list-style-type: decimal">
<li><p>Écrire une fonction de signature <code>prefixe_reseau(ip, masque)</code> qui retourne le préfixe réseau sous forme d’adresse IP V4 (type <code>str</code>) à partir d’une adresse IP V4 et d’un masque de sous-réseau.</p></li>
<li><p>Écrire une fonction de signature <code>suffixe_machine(ip, masque)</code> qui retourne le suffixe machine sous forme d’adresse IP V4 (type <code>str</code>) à partir d’une adresse IP V4 et d’un masque de sous-réseau.</p></li>
</ol>
<p>Voici un exemple de résultat attendu :</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a><span class="op">&gt;&gt;&gt;</span> prefixe_reseau(<span class="st">&#39;145.245.11.254&#39;</span>,<span class="st">&#39;255.255.252.0&#39;</span>)</span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="co">&#39;145.245.8.0&#39;</span></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="op">&gt;&gt;&gt;</span> suffixe_machine(<span class="st">&#39;145.245.11.254&#39;</span>,<span class="st">&#39;255.255.252.0&#39;</span>)</span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="co">&#39;0.0.3.254&#39;</span></span></code></pre></div>
</div>
<div class="propriete">
<p><code>Python</code> définit également des opérateurs sur les bits d’un nombre, plus efficaces que les opérations mathématiques équivalentes :</p>
<ul>
<li><p>Le décalage de <code>nombre</code> de <code>n</code> bits vers la gauche multiplie <code>nombre</code> par <span class="math inline">\(2^{n}\)</span> et s’écrit <code>nombre &lt;&lt; n</code>.</p></li>
<li><p>Le décalage de <code>nombre</code> de <code>n</code> bits vers la droite divise <code>nombre</code> par <span class="math inline">\(2^{n}\)</span> et s’écrit <code>nombre &gt;&gt; n</code>.</p></li>
</ul>
</div>
<div class="exercice">
<p>Dans l’algorithme de recherche dichotomique, après division en deux de la zone de recherche, l’algorithme s’appelle lui-même sur l’une des deux moitiés. C’est un algorithme de type <em>Diviser pour régner</em> qui peut se programmer récursivement comme nous le verrons en terminale dans le chapitre sur la récursivité.</p>
<p>Si on note <em>n</em> la taille de la liste, une autre implémentation, non récursive, est la suivante :</p>
<ul>
<li><p>on commence la recherche au début de la liste et on avance avec un pas <code>pas = n // 2</code> ou <code>pas = n &gt;&gt; 1</code> jusqu’au premier élément supérieur à l’élément cherché ;</p></li>
<li><p>on repart de l’élément précédent le point d’arrêt et on avance désormais avec un pas divisé par 2 soit :</p>
<p><code>pas = pas &gt;&gt; 1</code> ;</p></li>
<li><p>on répète en boucle ces instructions jusqu’à ce que le pas atteigne <span class="math inline">\(1\)</span>.</p></li>
</ul>
<p>A la fin de de la boucle, on détermine si l’élément précédent le dernier point d’arrêt est l’élément recherché.</p>
<p>Compléter le code de la fonction <code>recherche_dicho2</code> qui implémente cet algorithme.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">def</span> recherche_dicho2(L, e):</span>
<span id="cb7-2"><a href="#cb7-2"></a>    x, n  <span class="op">=</span> <span class="dv">0</span>, <span class="bu">len</span>(L)</span>
<span id="cb7-3"><a href="#cb7-3"></a>    pas <span class="op">=</span> n <span class="op">&gt;&gt;</span> <span class="dv">1</span></span>
<span id="cb7-4"><a href="#cb7-4"></a>    <span class="cf">while</span> pas <span class="op">&gt;=</span> <span class="dv">1</span>:</span>
<span id="cb7-5"><a href="#cb7-5"></a>        <span class="cf">while</span> x <span class="op">+</span> pas <span class="op">&lt;</span> n <span class="kw">and</span> .................:</span>
<span id="cb7-6"><a href="#cb7-6"></a>            x <span class="op">=</span> ..............</span>
<span id="cb7-7"><a href="#cb7-7"></a>        pas <span class="op">=</span> ................</span>
<span id="cb7-8"><a href="#cb7-8"></a>    <span class="cf">return</span> ............</span></code></pre></div>
</div>
</div>
</body>
</html>
